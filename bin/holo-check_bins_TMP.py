#16.04.2020 - Holoflow 0.1.

import subprocess
import argparse
import time
import os
import sys


#Argument parsing
parser = argparse.ArgumentParser(description='Runs holoflow pipeline.')
parser.add_argument('-binning_dir', help="binning directory", dest="binning_dir", required=True)
parser.add_argument('-check_mtb', help="empty check file", dest="check_mtb", required=True)
parser.add_argument('-check_mxb', help="empty check file", dest="check_mxb", required=True)
parser.add_argument('-check_file', help="empty check file", dest="check_file", required=True)
parser.add_argument('-ID', help="ID", dest="ID", required=True)
parser.add_argument('-log', help="pipeline log file", dest="log", required=True)

parser.add_argument('--check_cct', help="concoct check if empty", dest="check_cct")

args = parser.parse_args()


binning_dir=args.binning_dir
check_mxb=args.check_mxb
check_mtb=args.check_mtb
check_file=args.check_file
ID=args.ID
log=args.log

##############################################
#################### WRITE TO LOG ##########################
##############################################

true_bins=list()
false_bins=list()
final_check=binning_dir+'/'+ID+'_checked_bins'

######## Coassembly
if args.check_cct:
    with open(check_mxb,'r') as mxb, open(check_mtb,'r') as mtb, open(check_cct,'r') as cct:

        # Read whether it is True: there are bins or it is False: there are no bins
        check=list()
        check.append(mxb.readline())
        check.append(mtb.readline())
        check.append(cct.readline())

        for binner in check:
            if 'True' in binner:
                binner=binner.split(' ')[1]
                true_bins.append(binner)

            if 'False' in binner:
                binner=binner.split(' ')[1]
                false_bins.append(binner)

        # All binners generated bins, nothing to do
        if len(false_bins) == 0:
            os.remove(check_mxb)
            os.remove(check_mtb)
            os.remove(check_cct)
            pass

        # Some of all the  binners did not generate bins
        else:
            # At least one binner generated bins
            if len(true_bins) >= 1:
                t_binner=true_bins[0]
                t_bintable=binning_dir+'/'+ID+'.bins_'+t_binner+'.txt'
                t_bindir=os.path.join(binning_dir,ID+'_'+t_binner)

                for f_binner in false_bins:
                    f_bintable=binning_dir+'/'+ID+'.bins_'+f_binner+'.txt'
                    f_bindir=os.path.join(binning_dir,ID+'_'+f_binner)

                    # Duplicate bin table
                    if (not os.path.isfile(f_bintable)) or os.path.getsize(f_bintable) == 0:
                        cp_btCmd='cp '+t_bintable+' '+f_bintable+'.tmp && grep '+str(t_binner)+' '+f_bintable+'.tmp | sed s/'+str(t_binner)+'/dup_'+str(f_binner)+'/ > '+f_bintable+' && rm '+f_bintable+'.tmp'
                        subprocess.Popen(cp_btCmd,shell=True).wait()

                    # Duplicate bin directory
                        # Remove if exists, because it will be empty
                    if os.path.exists(f_bindir):
                        os.rmdir(f_bintable)
                        # Duplicate and rename
                    mv_bdCmd='cp -r '+t_bindir+' '+f_bindir+' && for f in '+f_bindir+'/*'+str(t_binner)+'* ; do mv "$f" "$(echo "$f" | sed s/'+str(t_binner)+'/dup_'+str(f_binner)+'/)"; done'
                    subprocess.Popen(mv_bdCmd,shell=True).wait()

                    # Check and finish
                    if f_binner == false_bins[-1] and os.path.isfile(f_bintable) and os.path.exists(f_bindir):
                        os.mknod(final_check)


            # No bins were generated at all
            if len(true_bins) == 0:
                with open(log,'a+') as log_file:
                    log_file.write('\n\n\n\t\t\tNo bins were generated by any binner, DASTool merging will not be possible\n\n\n')
                    sys.exit()


######## Individual assembly
else:
    with open(check_mxb,'r') as mxb, open(check_mtb,'r') as mtb:

        # Read whether it is True: there are bins or it is False: there are no bins
        check=list()
        check.append(mxb.readline())
        check.append(mtb.readline())

        for binner in check:
            if 'True' in binner:
                binner=binner.split(' ')[1]
                true_bins.append(binner)

            if 'False' in binner:
                binner=binner.split(' ')[1]
                false_bins.append(binner)

        # All binners generated bins, nothing to do
        if len(false_bins) == 0:
            os.remove(check_mxb)
            os.remove(check_mtb)
            pass

        # Some of all the  binners did not generate bins
        else:
            # At least one binner generated bins
            if len(true_bins) >= 1:
                t_binner=true_bins[0]
                t_bintable=binning_dir+'/'+ID+'.bins_'+t_binner+'.txt'
                t_bindir=os.path.join(binning_dir,ID+'_'+t_binner)

                for f_binner in false_bins:
                    f_bintable=binning_dir+'/'+ID+'.bins_'+f_binner+'.txt'
                    f_bindir=os.path.join(binning_dir,ID+'_'+f_binner)

                    # Duplicate bin table
                    if (not os.path.isfile(f_bintable)) or os.path.getsize(f_bintable) == 0:
                        cp_btCmd='cp '+t_bintable+' '+f_bintable+'.tmp && grep '+str(t_binner)+' '+f_bintable+'.tmp | sed s/'+str(t_binner)+'/dup_'+str(f_binner)+'/ > '+f_bintable+' && rm '+f_bintable+'.tmp'
                        subprocess.Popen(cp_btCmd,shell=True).wait()

                    # Duplicate bin directory
                        # Remove if exists, because it will be empty
                    if os.path.exists(f_bindir):
                        os.rmdir(f_bintable)
                        # Duplicate and rename
                    mv_bdCmd='cp -r '+t_bindir+' '+f_bindir+' && for f in '+f_bindir+'/*'+str(t_binner)+'* ; do mv "$f" "$(echo "$f" | sed s/'+str(t_binner)+'/dup_'+str(f_binner)+'/)"; done'
                    subprocess.Popen(mv_bdCmd,shell=True).wait()

                    # Check and finish
                    if f_binner == false_bins[-1] and os.path.isfile(f_bintable) and os.path.exists(f_bindir):
                        os.mknod(final_check)

            # No bins were generated at all
            if len(true_bins) == 0:
                with open(log,'a+') as log_file:
                    log_file.write('\n\n\n\t\t\tNo bins were generated by any binner, DASTool merging will not be possible\n\n\n')
                    sys.exit()
